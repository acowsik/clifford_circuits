from typing import Any, List, Tuple
import numpy as np

def pack_bits(bits: Any): ...
def unpack_bits(bits: Any): ...
def sq(x_string: Any, z_string: Any, location: Any, x_to: Any, z_to: Any) -> None: ...

class PauliString:
    cnot_mapping: List[List[bool]] = ...
    swap_mapping: List[List[bool]] = ...
    iswap_mapping: List[List[bool]] = ...
    z_string: Any = ...
    x_string: Any = ...
    def __init__(self, x_string: np.ndarray, z_string: np.ndarray) -> None: ...
    def __matmul__(self, other: PauliString): ...
    def anticommutes(self, other: PauliString) -> int: ...
    def copy(self) -> PauliString: ...
    def x_2(self, location: int) -> None: ...
    def y_2(self, location: int) -> None: ...
    def z_2(self, location: int) -> None: ...
    def cnot(self, control_loc: int, controlled_loc: int) -> None: ...
    def swap(self, control_loc: int, controlled_loc: int) -> None: ...
    def iswap(self, control_loc: int, controlled_loc: int) -> None: ...
    def identity(self, control_loc: int, controlled_loc: int) -> None: ...
    def single_qbit(self, location: int, x_to: Tuple[bool, bool], z_to: Tuple[bool, bool]) -> None: ...
    def __eq__(self, other: PauliString) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> bool: ...
    def left(self): ...
    def right(self): ...
    def stabilizer_length(self): ...

def x(n: int, length: int) -> PauliString: ...
def y(n: int, length: int) -> PauliString: ...
def z(n: int, length: int) -> PauliString: ...

class DensityMatrix:
    stabilizers: List[PauliString] = ...
    system_size: int = ...
    def __init__(self, stabilizers: List[PauliString]) -> None: ...
    def measure(self, operator: PauliString) -> None: ...
    def x_2(self, location: int) -> None: ...
    def y_2(self, location: int) -> None: ...
    def z_2(self, location: int) -> None: ...
    def cnot(self, control_loc: int, controlled_loc: int) -> None: ...
    def swap(self, control_loc: int, controlled_loc: int) -> None: ...
    def iswap(self, control_loc: int, controlled_loc: int) -> None: ...
    def identity(self, *args: Any, **kwargs: Any) -> None: ...
    def single_qbit(self, location: int, x_to: Tuple[bool, bool], z_to: Tuple[bool, bool]) -> None: ...
    def random_single_qbit(self, location: int) -> Any: ...
    def copy(self) -> DensityMatrix: ...
    def clip_gauge(self) -> None: ...
    def entropies_of_contiguous_regions(self, regions: List[Tuple[int]]) -> List[int]: ...
    def contiguous_entropy(self, left: int, right: int) -> int: ...
    def entropy(self, region: List[int]) -> int: ...
    def __len__(self): ...

class ChunkedState(DensityMatrix):
    z_operators: List[PauliString] = ...
    def __init__(self, stabilizers: List[PauliString]) -> None: ...
    def chunked_unitary(self, i_min: int, i_max: int, layers: int=...) -> None: ...
    def chunked_random_unitary(self, i_min: int, i_max: int) -> List[int]: ...
    def inverse_unitary(self, i_min: int, i_max: int, choices: List[int]) -> None: ...
    def chunked_measure(self, i_min: int, i_max: int) -> None: ...
    def chunked_random_measure(self, i_min: int, i_max: int) -> None: ...

def test() -> None: ...
def stabilizer_lengths(L: Any, p: Any): ...
def time(): ...
